# Helloworld ROS2 example

For this example we are going to setup a FIROS2 Bridge to be used to communicate FIWARE Orion contextBroker (NGSIv2 protocol) with ROS2 Listener example.

### Prerequisites:

- Installed and working ROS2 with Fast-RTPS and FIROS2.
- *ROS2* [Talker/Listener example](https://github.com/ros2/ros2/wiki/Linux-Development-Setup#try-some-examples>).

### Bridge library:

In this example, we will use the builtin library *isbridgengsiv2lib*, included with the installation of FIROS2.

### IDL files:

FIROS2 includes a JsonNGSIv2.idl, which will be used by the builtin NGSIv2 libraries. This IDL file is very simple, and contains two strings, *entityId* and *data*.

- *entityId* is intended to be filled with the entityId that will use contextBroker to identify the entity "Helloworld", by the **transformation library** (explained later) which will convert ngsiv2 data to ros2 protocol.

- *data* will contain raw JSON received from contextBroker.

To sending data to ROS2 we will use the String_.idl that encapsulates a string complatible with the used by the *talker/listener* demo in ROS2.

All this IDL files are already generated by *fastrtpsgen*, but maybe they need to be regenerated if *fastrtpsgen* changes in the future.

### Transformation library:

Following the example in templatelib.cpp, we have already created a library to transform from NGSIv2 to ROS2 (only transformation function is shown in order to clarity).

	extern "C" void USER_LIB_EXPORT transform(
			SerializedPayload_t *serialized_input,
			SerializedPayload_t *serialized_output)
	{
	    // User types
	    std_msgs::msg::dds_::String_ data;
	    std_msgs::msg::dds_::String_PubSubType data_pst;

	    JsonNGSIv2PubSubType string_pst;
	    JsonNGSIv2 string_data;

	    // Deserialization
	    string_pst.deserialize(serialized_input, &string_data);

	    // Custom transformation
	    std::stringstream ss(string_data.data());
	    Json::Value root;
	    Json::CharReaderBuilder jsonReader;
	    std::string errs;
	    if (Json::parseFromStream(jsonReader, ss, &root, &errs))
	    {
		Json::Value data_node = root["data"];
		Json::Value helloworld = data_node[0];
		data.data_("Helloworld: " + helloworld["count"]["value"].asString());
		// Serialization
		serialized_output->reserve(data_pst.m_typeSize);
		data_pst.serialize(&data, serialized_output);
	    }
	    else
	    {
		std::cout  << "Failed to parse" << errs;
	    }
	}


The logic is very simple. The function **transform** receives the data as a JsonNGSIv2 structure and creates a String with the data as expected by ROS2.

In both cases, serialization and deserialization are applied as needed by SerializedPayload_t.

### Config.xml

The *config.xml* file used in this example is the following:

    <is>
        <participant name="ros2">
            <attributes>
                <domain>0</domain>
            </attributes>

            <publisher name="ros2_publisher">
                <attributes>
                    <topic>chatter</topic>
                    <type>std_msgs::msg::dds_::String_</type>
                    <partition>rt</partition>
                </attributes>
            </publisher>
        </participant>

        <bridge name="ngsiv2">
            <library>libisbridgengsiv2lib.so</library> <!-- Path to the NGSIv2 library -->

            <subscriber name="ngsiv2_subscriber">
                <property>
                    <name>host</name>
                    <value>localhost</value>
                </property>
                <property>
                    <name>port</name>
                    <value>1026</value>
                </property>
                <property>
                    <name>id</name>
                    <value>Helloworld</value>
                </property>
                <property>
                    <name>type</name>
                    <value>Helloworld</value>
                </property>
                <property>
                    <name>notifs</name>
                    <value>count</value>
                </property>
                <property>
                    <name>listener_host</name>
                    <value>localhost</value>
                </property>
                <property>
                    <name>listener_port</name>
                    <value>12345</value>
                </property>
            </subscriber>
        </bridge>

        <connector name="domain_change"> 
            <subscriber participant_name="ngsiv2" subscriber_name="ngsiv2_subscriber"/>
            <publisher participant_name="ros2" publisher_name="ros2_publisher"/>
            <transformation file="/path/to/compiled/library/libuserlib.so" function="transform"/>
        </connector>
    </is>


Note that our transformation library will apply to NGSIv2 listener, so it is declared inside bridge_configuration under the tags "transformFromNGSIv2".

Our ROS2 Topic is chatter in the partition "rt" and with domain 0. Exactly the same configuration that talker/listener ROS2 example uses.
NGSIv2 will be configured to connect with a contextBroker server at localhost in port 1026, and will configure a subscription to any change in any entity of type "Helloworld", and asks to be notified only *count* attribute.

Finally we will listen to these changes at localhost in port 12345 (internally *libisbridgengsiv2lib* library launches the server to listen at the address specified in the subscription field).

### Run the example

FIrst, we need to compile the example transformation library (remember to have already installed and working ROS2, with Fast-RTPS and FIROS2).
Let's suppose our ROS2 path is **~/ros2**

	$ cd ~/ros2
	$ . ./install/local_setup.bash
	$ cd src/ros2/firos2/examples/helloworld_ros2
	$ mkdir build && cd build
	$ cmake ..
	$ make

In Windows:

	> cd C:\dev\ros2
	> call install\local_setup.bat
	> cd src\ros2\firos2\examples\helloworld_ros2
    > mkdir build && cd build
    > cmake .. -G "Visual Studio 14 2015 Win64"
    > cmake --build . --config Release
    > cd Release

Two auxiliary utilities are compiled:

**cb_create_helloworld**: Allows you to create a "Helloworld" entity with the expected structure in the Orion contextBroker.

	./cb_create_helloworld localhost:1026

This entity must exists in the contextBroker. If no url is specified, the "localhost:1026" will be used.

**cb_update_attr**: Allows you to modify an attribute value of a entity in the contextBroker.
The following example will modify *count* attribute of *Helloworld* entity setting its value to 5.

	./cb_update_attr localhost:1026 Helloworld count n 5

Finally, we are in condition to launch the test.
Let's suppose again that our ROS2 path is **~/ros2**

	$ cd ~/ros2
	$ . ./install/local_setup.bash
	$ cd src/ros2/firos2/examples/helloworld_ros2
	$ firos2 config.xml

In other terminal, launch ROS2 listener example:

	$ cd ~/ros2
	$ . ./install/local_setup.bash
	$ ros2 run demo_nodes_cpp listener

Now, you can check how ROS2's listener receives any change made in the *count* of "Helloworld" using *cb_update_attr*.
